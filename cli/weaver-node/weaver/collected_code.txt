{
  "metadata": {
    "collection_date": "2024-12-01",
    "collection_time": "07:18:55 UTC",
    "source_directory": "/home/jireh/projects/weaver/cli/weaver-node/weaver",
    "excluded_patterns": [],
    "file_extensions": [
      "py",
      "sh",
      "yml",
      "yaml",
      "js",
      "jsx",
      "java",
      "cpp",
      "c",
      "h",
      "hpp",
      "cs",
      "html",
      "css",
      "tsx",
      "ts",
      "go",
      "rb",
      "php",
      "scala",
      "rs",
      "swift"
    ],
    "system_info": {
      "platform": "linux",
      "cores": 16,
      "memory": "8GB"
    }
  },
  "statistics": {
    "total_files": 7,
    "total_lines": 443,
    "file_sizes": {
      "ts": 12346
    },
    "language_distribution": {
      "ts": 7
    }
  },
  "contents": "--- FILE: src/constants.ts ---\nLANGUAGE: ts\nBEGIN_CODE\nexport const DEFAULT_CONFIG = {\n  extensions: [\n    \"py\",\n    \"sh\",\n    \"yml\",\n    \"yaml\",\n    \"js\",\n    \"jsx\",\n    \"java\",\n    \"cpp\",\n    \"c\",\n    \"h\",\n    \"hpp\",\n    \"cs\",\n    \"html\",\n    \"css\",\n    \"tsx\",\n    \"ts\",\n    \"go\",\n    \"rb\",\n    \"php\",\n    \"scala\",\n    \"rs\",\n    \"swift\",\n  ],\n  excludePatterns: [\n    \".git\",\n    \".svn\",\n    \".hg\",\n    \"package-lock.json\",\n    \"node_modules\",\n    \"vendor\",\n    \"build\",\n    \"dist\",\n    \"target\",\n    \".next\",\n    \"__pycache__\",\n    \"*.pyc\",\n    \"venv\",\n    \".env\",\n    \".venv\",\n  ],\n  apiEndpoint: \"http://weaver-api.spencerjireh.com/api/text\",\n  concurrency: 4,\n  format: \"json\" as const,\n};\n\nEND_CODE\n\n--- FILE: src/types.ts ---\nLANGUAGE: ts\nBEGIN_CODE\nexport interface Metadata {\n  collection_date: string;\n  collection_time: string;\n  source_directory: string;\n  excluded_patterns: string[];\n  file_extensions: string[];\n  system_info: {\n    platform: string;\n    cores: number;\n    memory: string;\n  };\n}\n\nexport interface Statistics {\n  total_files: number;\n  total_lines: number;\n  file_sizes: { [key: string]: number };\n  language_distribution: { [key: string]: number };\n}\n\nexport interface Config {\n  outputFile: string;\n  searchDir: string;\n  extensions: string[];\n  excludePatterns: string[];\n  useDefaultExcludes: boolean;\n  quietMode: boolean;\n  concurrency: number;\n  skipUpload: boolean;\n  apiEndpoint: string;\n  format: \"json\" | \"text\";\n}\n\nexport interface ProcessedFile {\n  path: string;\n  content: string;\n  lines: number;\n  size: number;\n  extension: string;\n}\n\n\n\nEND_CODE\n\n--- FILE: src/index.ts ---\nLANGUAGE: ts\nBEGIN_CODE\nimport { promises as fs } from \"fs\";\nimport chalk from \"chalk\";\nimport { FileProcessingService } from \"./services/file-processing.service.js\";\nimport { DataCollectionService } from \"./services/data-collection.service.js\";\nimport { UploadService } from \"./services/upload.service.js\";\nimport { setupCLI } from \"./cli.js\";\n\nexport async function main(): Promise<void> {\n  try {\n    const config = setupCLI();\n    const fileService = new FileProcessingService(config);\n    const dataService = new DataCollectionService(fileService, config);\n    const uploadService = new UploadService(config);\n\n    const { metadata, statistics, contents } = await dataService.collect();\n\n    const output =\n      config.format === \"json\"\n        ? JSON.stringify({ metadata, statistics, contents }, null, 2)\n        : [\n            \"<METADATA>\",\n            Object.entries(metadata)\n              .map(\n                ([key, value]) => `${key}: ${JSON.stringify(value, null, 2)}`\n              )\n              .join(\"\\n\"),\n            \"</METADATA>\\n\",\n            \"<STATISTICS>\",\n            Object.entries(statistics)\n              .map(\n                ([key, value]) => `${key}: ${JSON.stringify(value, null, 2)}`\n              )\n              .join(\"\\n\"),\n            \"</STATISTICS>\\n\",\n            \"<CODE_CONTENTS>\",\n            contents,\n            \"</CODE_CONTENTS>\",\n          ].join(\"\\n\");\n\n    await fs.writeFile(config.outputFile, output);\n\n    if (!config.skipUpload) {\n      await uploadService.upload(output);\n    }\n\n    if (!config.quietMode) {\n      console.log(\n        chalk.green(`\nCollection complete:\n- Total files: ${statistics.total_files}\n- Total lines: ${statistics.total_lines}\n- Output saved to: ${config.outputFile}\n      `)\n      );\n    }\n  } catch (error) {\n    console.error(chalk.red(\"Error:\"), error);\n    process.exit(1);\n  }\n}\n\nEND_CODE\n\n--- FILE: src/services/upload.service.ts ---\nLANGUAGE: ts\nBEGIN_CODE\nimport fetch from \"node-fetch\";\nimport { createSpinner } from \"nanospinner\";\nimport { Config } from \"../types.js\";\n\nexport class UploadService {\n  private readonly CHUNK_SIZE = 1024 * 1024; // 1MB\n\n  constructor(private readonly config: Config) {}\n\n  async upload(content: string): Promise<void> {\n    const chunks = this.splitIntoChunks(content);\n    const spinner = createSpinner(\"Uploading content...\").start();\n\n    try {\n      await this.uploadChunks(chunks);\n      spinner.success({ text: \"Upload complete\" });\n    } catch (error) {\n      spinner.error({ text: \"Upload failed\" });\n      throw error;\n    }\n  }\n\n  private splitIntoChunks(content: string): string[] {\n    const chunks = [];\n    for (let i = 0; i < content.length; i += this.CHUNK_SIZE) {\n      chunks.push(content.slice(i, i + this.CHUNK_SIZE));\n    }\n    return chunks;\n  }\n\n  private async uploadChunks(chunks: string[]): Promise<void> {\n    for (let i = 0; i < chunks.length; i++) {\n      try {\n        const response = await fetch(this.config.apiEndpoint, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ content: chunks[i] }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n      } catch (error) {\n        throw new Error(`Error uploading chunk ${i + 1}: ${error}`);\n      }\n    }\n  }\n}\n\nEND_CODE\n\n--- FILE: src/services/file-processing.service.ts ---\nLANGUAGE: ts\nBEGIN_CODE\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { Config, ProcessedFile } from \"../types.js\";\nimport { DEFAULT_CONFIG } from \"../constants.js\";\n\nexport class FileProcessingService {\n  private readonly execAsync = promisify(exec);\n\n  constructor(private readonly config: Config) {}\n\n  async findFiles(): Promise<string[]> {\n    try {\n      // Log the search directory for debugging\n      console.log(`Searching in directory: ${this.config.searchDir}`);\n\n      const excludeArgs = this.buildExcludeArgs();\n      const extensionPattern = this.buildExtensionPattern();\n\n      // Changed the find command to be more compatible and added error checking\n      const cmd = `find \"${this.config.searchDir}\" -type f ${excludeArgs} \\\\( ${extensionPattern} \\\\)`;\n\n      console.log(`Executing command: ${cmd}`); // Debug log\n\n      const { stdout, stderr } = await this.execAsync(cmd);\n\n      if (stderr) {\n        console.error(`Find command stderr: ${stderr}`);\n      }\n\n      const files = stdout.trim().split(\"\\n\").filter(Boolean);\n      console.log(`Found ${files.length} files`); // Debug log\n\n      return files;\n    } catch (error) {\n      console.error(`Error finding files: ${error}`);\n      throw error;\n    }\n  }\n\n  private buildExcludeArgs(): string {\n    const patterns = this.config.excludePatterns.concat(\n      this.config.useDefaultExcludes ? DEFAULT_CONFIG.excludePatterns : []\n    );\n\n    return patterns.map((pattern) => `-not -path \"*${pattern}*\"`).join(\" \");\n  }\n\n  private buildExtensionPattern(): string {\n    return this.config.extensions.map((ext) => `-name \"*.${ext}\"`).join(\" -o \");\n  }\n\n  async processFile(filePath: string): Promise<ProcessedFile> {\n    try {\n      const content = await fs.promises.readFile(filePath, \"utf8\");\n      const stats = await fs.promises.stat(filePath);\n      return {\n        path: filePath,\n        content,\n        lines: content.split(\"\\n\").length,\n        size: stats.size,\n        extension: path.extname(filePath).slice(1),\n      };\n    } catch (error) {\n      throw new Error(`Error processing ${filePath}: ${error}`);\n    }\n  }\n}\n\nEND_CODE\n\n--- FILE: src/services/data-collection.service.ts ---\nLANGUAGE: ts\nBEGIN_CODE\nimport * as path from \"path\";\nimport * as os from \"os\";\nimport { from } from \"rxjs\";\nimport { map, mergeMap, toArray } from \"rxjs/operators\";\nimport { createSpinner } from \"nanospinner\";\nimport { Config, Metadata, Statistics, ProcessedFile } from \"../types.js\";\nimport { FileProcessingService } from \"./file-processing.service.js\";\n\nexport class DataCollectionService {\n  constructor(\n    private readonly fileService: FileProcessingService,\n    private readonly config: Config\n  ) {}\n\n  async collect(): Promise<{\n    metadata: Metadata;\n    statistics: Statistics;\n    contents: string;\n  }> {\n    const files = await this.fileService.findFiles();\n    if (files.length === 0) {\n      throw new Error(\"No matching files found\");\n    }\n\n    const processedFiles = await this.processFilesWithProgress(files);\n    const statistics = this.calculateStatistics(processedFiles);\n    const metadata = this.generateMetadata();\n    const contents = this.formatContents(processedFiles);\n\n    return { metadata, statistics, contents };\n  }\n\n  private async processFilesWithProgress(\n    files: string[]\n  ): Promise<ProcessedFile[]> {\n    const spinner = createSpinner(\"Processing files...\").start();\n    const processed = await this.processFilesInParallel(files);\n    spinner.success({ text: \"Files processed successfully\" });\n    return processed;\n  }\n\n  private processFilesInParallel(files: string[]): Promise<ProcessedFile[]> {\n    return new Promise((resolve) => {\n      from(files)\n        .pipe(\n          mergeMap(\n            (file) => from(this.fileService.processFile(file)),\n            this.config.concurrency\n          ),\n          toArray() // Collect all processed files into an array\n        )\n        .subscribe({\n          next: (processedFiles) => resolve(processedFiles),\n          error: (error) => {\n            console.error(\"Error processing files:\", error);\n            resolve([]); // Return empty array on error instead of rejecting\n          },\n        });\n    });\n  }\n\n  private calculateStatistics(files: ProcessedFile[]): Statistics {\n    return {\n      total_files: files.length,\n      total_lines: files.reduce((acc, file) => acc + file.lines, 0),\n      file_sizes: files.reduce(\n        (acc: { [key: string]: number }, file) => ({\n          ...acc,\n          [file.extension]: (acc[file.extension] || 0) + file.size,\n        }),\n        {}\n      ),\n      language_distribution: files.reduce(\n        (acc: { [key: string]: number }, file) => ({\n          ...acc,\n          [file.extension]: (acc[file.extension] || 0) + 1,\n        }),\n        {}\n      ),\n    };\n  }\n\n  private generateMetadata(): Metadata {\n    return {\n      collection_date: new Date().toISOString().split(\"T\")[0],\n      collection_time:\n        new Date().toISOString().split(\"T\")[1].split(\".\")[0] + \" UTC\",\n      source_directory: path.resolve(this.config.searchDir),\n      excluded_patterns: this.config.excludePatterns,\n      file_extensions: this.config.extensions,\n      system_info: {\n        platform: os.platform(),\n        cores: os.cpus().length,\n        memory: `${Math.round(os.totalmem() / (1024 * 1024 * 1024))}GB`,\n      },\n    };\n  }\n\n  private formatContents(files: ProcessedFile[]): string {\n    return files\n      .map((file) => {\n        const relativePath = path.relative(this.config.searchDir, file.path);\n        return [\n          `--- FILE: ${relativePath} ---`,\n          `LANGUAGE: ${file.extension}`,\n          \"BEGIN_CODE\",\n          file.content,\n          \"END_CODE\\n\",\n        ].join(\"\\n\");\n      })\n      .join(\"\\n\");\n  }\n}\n\nEND_CODE\n\n--- FILE: src/cli.ts ---\nLANGUAGE: ts\nBEGIN_CODE\n#!/usr/bin/env node\nimport { program } from \"commander\";\nimport { fileURLToPath } from \"url\";\nimport { dirname } from \"path\";\nimport { Config } from \"./types.js\";\nimport { DEFAULT_CONFIG } from \"./constants.js\";\nimport { main } from \"./index.js\";\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n\nexport function setupCLI(): Config {\n  program\n    .option(\"-d, --dir <directory>\", \"Search directory\", \".\")\n    .option(\"-o, --output <file>\", \"Output filename\", \"collected_code.txt\")\n    .option(\n      \"-e, --extensions <list>\",\n      \"File extensions to include (comma-separated)\"\n    )\n    .option(\n      \"-x, --exclude <patterns>\",\n      \"Additional patterns to exclude (comma-separated)\"\n    )\n    .option(\"-a, --all\", \"Disable default exclusions\")\n    .option(\"-q, --quiet\", \"Quiet mode - suppress progress messages\")\n    .option(\n      \"-c, --concurrency <number>\",\n      \"Number of concurrent file operations\",\n      \"4\"\n    )\n    .option(\"--skip-upload\", \"Skip uploading to server\")\n    .option(\"--api-endpoint <url>\", \"Custom API endpoint\")\n    .option(\"--format <type>\", \"Output format (json or text)\", \"json\")\n    .parse(process.argv);\n\n  const options = program.opts();\n\n  return {\n    outputFile: options.output,\n    searchDir: options.dir,\n    extensions: options.extensions\n      ? options.extensions.split(\",\")\n      : DEFAULT_CONFIG.extensions,\n    excludePatterns: options.exclude ? options.exclude.split(\",\") : [],\n    useDefaultExcludes: !options.all,\n    quietMode: options.quiet || false,\n    concurrency: parseInt(options.concurrency, 10),\n    skipUpload: options.skipUpload || false,\n    apiEndpoint: options.apiEndpoint || DEFAULT_CONFIG.apiEndpoint,\n    format: options.format as \"json\" | \"text\",\n  };\n}\n\n// Immediately execute main when run as CLI\nmain().catch((error) => {\n  console.error(\"Error:\", error);\n  process.exit(1);\n});\n\nEND_CODE\n"
}